# AI 编码心智模型

> 在让 AI 写代码的同时，持续跳出代码本身，思考"我在怎么让 AI 写代码"。

---

## 一、痛点：AI 编码为什么没有想象中提效？

AI 编码工具越来越强大，但很多人的真实体验是：

- **代码质量不稳定** - 有时候很惊艳，有时候一塌糊涂
- **反复修改更耗时** - AI 生成的代码改来改去，还不如自己写
- **线上频繁出 bug** - AI 写的代码看着没问题，上线就炸
- **团队无法复用** - 每个人都有自己的一套方法，经验无法传承

**核心矛盾**：AI 能力很强，但我们不知道怎么正确使用它。

---

## 二、Vibe Coding 的常见误区

为什么会有这些痛点？因为很多人陷入了这些坑：

### 误区 1：直接甩需求

**表现**：把 PRD 或口头需求直接丢给 AI，期待一步到位

**问题**：
- AI 不理解你的工程结构，代码不知道放哪
- AI 不理解你的规范，风格不统一
- 需求描述模糊，AI 只能猜测

**本质**：**输入质量差，输出必然差**

### 误区 2：任务粒度失控

**表现**：让 AI 一次性写整个模块，或者一行一行地问

**问题**：
- 粒度太大：AI 幻觉严重，质量无法保障
- 粒度太小：来回对话，效率比手写还低

**本质**：**没有找到 AI 能力的甜蜜点**

### 误区 3：生成即完成

**表现**：AI 生成代码后直接用，不验证、不审查

**问题**：
- AI 生成内容基于概率，幻觉不可避免
- 逻辑漏洞、边界问题人眼难发现
- 线上出 bug 才发现问题

**本质**：**缺乏质量闭环**

### 误区 4：每人一套方案

**表现**：团队中每个人都有自己的 Prompt 和方法

**问题**：
- 经验无法复用，重复踩坑
- 代码风格不统一
- 新人上手成本高

**本质**：**没有抽象沉淀**

---

## 三、核心定义

**高质量 AI 编码** = 在使用 AI 编码的过程中，保持对输入质量、任务粒度、验证闭环的觉察和优化。

不只是让 AI 写代码，而是同时追问：
- 我给 AI 的输入够清晰吗？（输入质量）
- 任务拆分合理吗？（粒度控制）
- 生成的代码怎么验证？（质量闭环）
- 这套方法能复用吗？（抽象沉淀）

---

## 四、问题本质：AI 编码的四个关键变量

```
AI 编码质量 = f(输入质量, 任务粒度, 验证机制, 可复用性)
```

| 变量 | 问题 | 解决思路 |
|------|------|----------|
| **输入质量** | AI 不理解需求和上下文 | 技术方案模版 + 工程结构描述 |
| **任务粒度** | 太大幻觉、太小低效 | 类级别任务拆分 |
| **验证机制** | 生成即完成，缺乏闭环 | 五道质量防线 |
| **可复用性** | 每人一套，无法推广 | Prompt 不含业务逻辑 |

---

## 五、四个核心动作

### 1. 定规范（保障输入质量）

**原则**：先清晰描述，再让 AI 动手

**做法**：
- 设计技术方案模版，统一业务描述格式
- 用 DDD 思想引导模块划分
- 让 AI 生成工程结构描述，确认后再编码

**模版结构**：
```
业务功能 = 业务流程 + 业务逻辑 + 业务规则 + 数据模型
```

**自检**：我给 AI 的输入，换一个人看能理解吗？

### 2. 控粒度（找到甜蜜点）

**原则**：不求一步到位，也不逐行询问

**粒度谱系**：
```
工程级 → 模块级 → 类级 → 函数级 → 代码块级 → 行级
                    ↑
                 最佳粒度
```

**做法**：
- 按「领域服务」和「服务接口」拆分任务
- 分层次（数据层→业务层→应用层）分领域编码
- 每次给 AI 一个类级别的任务

**自检**：这个任务 AI 能一次性完成吗？完成后我能快速验证吗？

### 3. 建防线（质量闭环）

**原则**：每个阶段都有验证机制

**五道防线**：

| 防线 | 验证内容 | AI 角色 |
|------|----------|---------|
| 技术方案 Review | 需求与方案一致性 | 辅助 |
| 需求实现 Review | 代码与方案一致性 | 主导 |
| AI 代码 CR | 逻辑问题、健壮性 | 主导 |
| 测试用例验证 | 功能正确性 | 辅助 |
| 测试质量保障 | 专业验证 | 辅助 |

**自检**：如果这段代码出 bug，我能在哪道防线发现？

### 4. 可复用（抽象沉淀）

**原则**：Prompt 不含业务逻辑，方法可复刻

**做法**：
- Prompt 按架构分层设计（数据层/业务层/应用层）
- Prompt 只讲规范和要求，不含具体业务
- 技术方案模版承载业务逻辑，Prompt 承载编码规范

**Prompt 设计原则**：
```
讲规范 + 明要求 + 可复用
```

**自检**：换一个需求，这套 Prompt 还能用吗？

---

## 六、思维路径

```
需求分析 → 技术方案 → 任务拆分 → AI 编码 → 质量验证 → 抽象沉淀
    ↑                                                      ↓
    ←←←←←←←←←←←←←← 迭代优化 ←←←←←←←←←←←←←←←←←←←←←←←←←←←←
```

**关键**：这是一个闭环，每次编码都在验证和优化方法论。

---

## 七、应用场景

### 新增类需求（侧重设计）

```
PRD → 新增类 Prompt + 技术方案模版 → 方案设计 → 模块拆分 → AI 编码
```

**重点**：业务逻辑描述清晰、模块划分合理

### 修改类需求（侧重梳理）

```
PRD → 按应用拆分 → 修改类 Prompt + 工程代码 → 改动点分析 → AI 编码
```

**重点**：理解现有代码、明确改动范围

---

## 八、团队推广策略

| 阶段 | 方法 | 关键动作 |
|------|------|----------|
| **启动期** | 传帮带 | 结对编程，One By One |
| **扩散期** | 实践分享 | 先行者总结经验，团队分享 |
| **固化期** | 激励机制 | AI 先锋评优，形成正向循环 |

**关键**：不命令式推广，用氛围和实践引导

---

## 九、核心公式

```
高质量 AI 编码 = 技术方案模版（输入质量）
              + Prompt 规范（输出约束）
              + 类级别拆分（任务粒度）
              + 五道防线（质量闭环）
```

---

## 十、一句话总结

**AI 编码提效** = 在让 AI 写代码的同时，持续追问"我在怎么让 AI 写代码"，把一次性的编码经验变成可复用的方法论。

核心心法：**定规范 → 控粒度 → 建防线 → 可复用**

常见误区：**直接甩需求、粒度失控、生成即完成、每人一套**

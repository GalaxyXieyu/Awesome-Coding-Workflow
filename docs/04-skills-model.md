# Skills 抽象模型

## 核心抽象

### Skill 的本质

```
Skill = f(Context, Rules) → Output
```

一个 Skill 本质上是一个**受约束的函数**：
- **输入**：上下文信息
- **约束**：Rules 定义的边界
- **输出**：标准化的结果

## 设计模式

### 模式一：任务型 Skill

专注于完成特定任务。

```
┌─────────────────────────────────────┐
│           任务型 Skill              │
├─────────────────────────────────────┤
│ 特点：                              │
│ - 明确的输入输出                    │
│ - 固定的执行步骤                    │
│ - 可验证的结果                      │
├─────────────────────────────────────┤
│ 适用场景：                          │
│ - 代码生成                          │
│ - 数据转换                          │
│ - 文档生成                          │
└─────────────────────────────────────┘
```

**示例**：
```markdown
# API 文档生成 Skill
输入: API 代码文件
输出: OpenAPI 规范文档
步骤: 解析 → 提取 → 格式化 → 输出
```

### 模式二：流程型 Skill

管理多步骤工作流。

```
┌─────────────────────────────────────┐
│           流程型 Skill              │
├─────────────────────────────────────┤
│ 特点：                              │
│ - 多个阶段                          │
│ - 阶段间有状态传递                  │
│ - 支持条件分支                      │
├─────────────────────────────────────┤
│ 适用场景：                          │
│ - 项目初始化                        │
│ - 代码审查流程                      │
│ - 发布部署                          │
└─────────────────────────────────────┘
```

**示例**：
```markdown
# 代码审查 Skill
阶段 1: 静态分析 → 阶段 2: 安全检查 → 阶段 3: 性能分析 → 阶段 4: 生成报告
```

### 模式三：智能体型 Skill

具有自主决策能力。

```
┌─────────────────────────────────────┐
│          智能体型 Skill             │
├─────────────────────────────────────┤
│ 特点：                              │
│ - 可自主规划                        │
│ - 动态调整策略                      │
│ - 迭代优化                          │
├─────────────────────────────────────┤
│ 适用场景：                          │
│ - 问题诊断                          │
│ - 需求分析                          │
│ - 探索性任务                        │
└─────────────────────────────────────┘
```

## 抽象层级

```
Level 3: 组合 Skill
         │
         │  由多个基础 Skill 组合而成
         │
         ▼
Level 2: 领域 Skill
         │
         │  特定领域的专业能力
         │
         ▼
Level 1: 原子 Skill
         │
         │  最小粒度的可复用能力
         │
         ▼
Level 0: 基础能力
         
         Claude Code 内置能力
```

### 各层级示例

| 层级 | 示例 | 说明 |
|------|------|------|
| Level 0 | 代码补全、文件读写 | 内置能力 |
| Level 1 | 函数提取、变量重命名 | 原子操作 |
| Level 2 | React 组件生成、SQL 优化 | 领域专业 |
| Level 3 | 全栈功能开发 | 多 Skill 组合 |

## Skill 接口规范

### 标准接口定义

```typescript
interface Skill {
  // 元信息
  metadata: {
    name: string;
    version: string;
    description: string;
    tags: string[];
  };
  
  // 触发条件
  trigger: {
    explicit: string[];      // 显式命令
    patterns: string[];      // 匹配模式
    conditions: Condition[]; // 条件规则
  };
  
  // 上下文要求
  context: {
    required: ContextItem[];
    optional: ContextItem[];
  };
  
  // 执行逻辑
  execute: (ctx: Context, rules: Rules) => Output;
  
  // 输出规范
  output: {
    format: 'markdown' | 'json' | 'code' | 'mixed';
    schema?: OutputSchema;
  };
  
  // 约束条件
  constraints: Constraint[];
}
```

## 状态管理

### 无状态 Skill

```
输入 ──► 处理 ──► 输出
         │
    (无副作用)
```

适用于：格式转换、计算任务

### 有状态 Skill

```
输入 ──► 处理 ──► 输出
         │
    ┌────┴────┐
    │  状态   │
    │  存储   │
    └─────────┘
```

适用于：迭代任务、上下文相关任务

## 组合模式

### 串行组合

```markdown
Skill A → Skill B → Skill C

适用于：流水线处理
示例：解析 → 转换 → 验证
```

### 并行组合

```markdown
      ┌→ Skill A ─┐
输入 ─┼→ Skill B ─┼→ 聚合 → 输出
      └→ Skill C ─┘

适用于：多维度分析
示例：同时进行安全检查、性能分析、代码规范检查
```

### 条件组合

```markdown
        ┌── 条件A ──► Skill A
输入 ──┤
        └── 条件B ──► Skill B

适用于：分支处理
示例：根据文件类型选择不同处理 Skill
```

## 设计原则

### 1. 单一职责
每个 Skill 只做一件事，做好一件事

### 2. 可组合性
设计时考虑与其他 Skill 的组合可能

### 3. 幂等性
相同输入产生相同输出（无状态 Skill）

### 4. 可测试性
提供清晰的输入输出便于测试验证

### 5. 渐进增强
从简单开始，逐步增加复杂度

## 下一步

阅读 [05-skills-import.md](05-skills-import.md) 了解导入引用方法。
